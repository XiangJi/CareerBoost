package DSA.BFS.FindBicycle;

/*
 * 找自行车，二维平面上给定一堆人和一堆自行车，假定所有的人都是贪婪的且非常聪明（会直奔自己肯定能拿到的那辆车），要求给定一个人，问他会拿到哪一辆车
 * 一个矩阵里N个人N辆车，每个人自己定一辆合适的目标车去取。
 * 构建图用BFS
 * 或者dfs也行
 * 高频题 一定要写一遍
 *
 * 我的算法：把每个人同时进Q, 然后同时开始bfs 碰到车就拿掉 然后停止搜索 求这个人拿到哪个车
 * 不能暴力做 用heap存关系
 * 既然是矩阵就使用matrix构图
 *
 *
 *https://www.careercup.com/question?id=5664498449907712
 *
 *2D平面上，有m个人（P），n辆自行车(B)，还有空白（O）满足以下条件
1.m < n
2.不存在两个人，到同一辆自行车距离相等, 距离用abs(x1-x2) + abs(y1-y2)定义
3.每个人尽量找离自己最近的自行车，一旦某辆自行车被占，其他人只能找别的自行车。

例
OPOBOOP 来源一亩.三分地论坛.
OOOOOOO
OOOOOOO
OOOOOOO
BOOBOOB
. from: 1point3acres
红色的人找到第一行的自行车，距离最近。
蓝色的人离第一行自行车最近，但自行车已经被红色人占有，所以他只能找离他第二近的，右下角的自行车。

问：把人和自行车配对，输出vector<pair<int, int>>每个人对应的自行车. {i, j} 是人i对应自行车j

 * 从人0车0 人1车1 这样的搭配找出总共的路程，然后人0车1，人1车2。。。这样
 *
找出人车之间的distance的那个函数interviewer说你不用写了，我就写了个getDists(...);

让自己设计输入输出。。我说那就matrix bfs吧，他说时间复杂度咋样，我说(mn)^2他说你给我优化优化。
这个地方我跑偏了，以为要bfs基础优化。。。怼了半天怼不出来。. visit 1point3acres for more.
他说，你要不要试试改变输入。。我说可以这样玩的吗，他说对啊。。。输入都你自己定的。。
这个时候已经浪费太多时间在第一种输入上了。。我有一种日了狗的感觉。
我说那就两个array。一个车的坐标，一个人的坐标。长度分别为m n， 算一个m n的矩阵，里面元素为每辆车到每个人的曼哈顿距离。
他说可以有。。继续。。我想了几分钟，说来个min heap，
距离全压进去，一个一个弹出来，看这个距离里的车跟人有没匹配过。没匹配过的就是新的匹配。然后把匹配的车跟人记录下来，继续一直到结束。
他点了点头。。说你写吧。。
写完比较器的override，开始while，没时间了。呵呵哒。

 */
public class Solution {

}
